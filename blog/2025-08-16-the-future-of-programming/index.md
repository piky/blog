---
title: Bret Victor - The Future of Programming
slug: the-future-of-programming
description: อนาคตของการเขียนโปรแกรมในอีก 40 ปีข้างหน้า
authors: piky
tags: [fyi, note]
keywords: [unlearnt, programming, technology]
---
<iframe width="560" height="315" src="https://www.youtube.com/embed/8pTEmbeENF4?si=smOf1zdCb2D5qeJG" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
# อนาคตของการเขียนโปรแกรม: สี่แนวคิดพลิกโฉม
ในคลิปวิดีโอนี้ กล่าวถึง **อนาคตของการเขียนโปรแกรม** วิทยากรได้นำเสนอแนวคิดสำคัญ 4 ประการที่คาดว่าจะเปลี่ยนโฉมการเขียนโค้ดในอีก 40 ปีข้างหน้า  
ประการแรกคือ **การจัดการข้อมูลโดยตรง** ซึ่งจะทำให้ผู้ใช้สามารถสร้างโปรแกรมได้โดยไม่ต้องเขียนโค้ด แต่ผ่านการโต้ตอบกับข้อมูลโดยตรง  
ประการที่สองคือ **การเขียนโปรแกรมโดยใช้เป้าหมาย** ซึ่งเน้นการระบุผลลัพธ์ที่ต้องการแทนการกำหนดขั้นตอนทีละขั้น ให้คอมพิวเตอร์เป็นผู้หาทางออกเอง  
ประการที่สามคือ **การแสดงข้อมูลเชิงพื้นที่** แทนที่จะใช้ไฟล์ข้อความยาวๆ โปรแกรมจะถูกจัดระเบียบและแสดงผลในรูปแบบกราฟิกบนหน้าจอ  
และประการสุดท้ายคือ **โมเดลการเขียนโปรแกรมแบบคู่ขนาน** เพื่อรองรับฮาร์ดแวร์แบบมัลติโปรเซสเซอร์ที่กำลังจะมาถึง โดยทิ้งแนวคิดแบบลำดับและการใช้เธรดและล็อกที่ล้าสมัย  
โดยภาพรวมแล้ว วิทยากรชี้ให้เห็นว่า**เทคโนโลยีเปลี่ยนแปลงอย่างรวดเร็ว แต่ความคิดของผู้คนมักปรับตัวช้า** และเตือนว่าการยึดติดกับแนวคิดเดิมๆ อาจทำให้มองไม่เห็นนวัตกรรมใหม่ๆ ที่มีประสิทธิภาพมากกว่า
<!-- truncate -->
## สรุปเนื้อหา
วิดีโอ "Bret Victor The Future of Programming" นำเสนอโดย "Joey Reid" กล่าวถึงการเปลี่ยนแปลงอย่างรวดเร็วในวงการคอมพิวเตอร์และคาดการณ์อนาคตของการเขียนโปรแกรมในอีก 40 ปีข้างหน้า โดยอาศัยงานวิจัยที่น่าสนใจในช่วง 10 ปีที่ผ่านมา

ผู้บรรยายเริ่มต้นด้วยการเน้นย้ำว่า **เทคโนโลยีเปลี่ยนแปลงอย่างรวดเร็ว แต่ความคิดของผู้คนเปลี่ยนแปลงช้า** เขายกตัวอย่างกฎของมัวร์ (Moore's Law) ที่ระบุว่าขีดความสามารถของคอมพิวเตอร์เพิ่มขึ้นแบบทวีคูณ ซึ่งเป็นสิ่งที่เกิดขึ้นเองตามธรรมชาติ แต่การที่ผู้คนจะยอมรับแนวคิดใหม่ๆ นั้นเป็นเรื่องยาก

มีการยกตัวอย่างประวัติศาสตร์การเขียนโปรแกรมเพื่อแสดงให้เห็นถึงการต่อต้านแนวคิดใหม่ๆ

*   **จากไบนารีสู่อัสเซมบลี:** ในยุคแรกของการเขียนโปรแกรมด้วยคอมพิวเตอร์ IBM 650 ผู้คนเขียนโปรแกรมด้วยรหัสไบนารีโดยตรง เมื่อ Stan Poley ประดิษฐ์ Assembler ซึ่งช่วยให้เขียนโปรแกรมด้วยสัญลักษณ์และตัวแปรได้ ทำให้มีประสิทธิภาพและลดข้อผิดพลาดมากขึ้น แต่โปรแกรมเมอร์ไบนารีกลับไม่สนใจและไม่เห็นคุณค่า John von Neumann นักวิทยาศาสตร์ผู้ยิ่งใหญ่ถึงกับไม่พอใจอย่างมากเมื่อนักศึกษาของเขาเขียน Assembler เพราะมองว่าเป็นการสิ้นเปลืองเวลาของเครื่องจักรสำหรับงานธุรการ
*   **จากอัสเซมบลีสู่ฟอร์แทรน:** ต่อมา John Backus และเพื่อนๆ ได้คิดค้น Fortran ซึ่งเป็นภาษาระดับสูงที่สามารถเขียนสูตรคณิตศาสตร์และลูปได้ แต่โปรแกรมเมอร์ Assembler ก็ไม่สนใจเช่นกัน

ผู้บรรยายเน้นย้ำว่า **เป็นเรื่องง่ายที่จะคิดว่าเทคโนโลยีจะดีขึ้นเรื่อยๆ แต่แนวคิดที่ต้องให้คน "เลิกเรียนรู้" สิ่งที่เคยรู้มาและคิดในรูปแบบใหม่มักจะได้รับการต่อต้านอย่างมาก** ผู้คนมักจะคิดว่าพวกเขารู้แล้วว่าการเขียนโปรแกรมคืออะไร และปฏิเสธแนวทางใหม่ๆ

หลังจากนั้น ผู้บรรยายได้นำเสนอ **สี่แนวคิดสำคัญ** ที่จะกำหนดอนาคตของการเขียนโปรแกรม:

*   **1. การจัดการข้อมูลโดยตรง (Direct Manipulation of Data):**
    *   ปัจจุบันเราเขียนโปรแกรมด้วยชุดคำสั่ง แต่ในอนาคตจะมีการวิจัยที่น่าสนใจเกี่ยวกับการจัดการโครงสร้างข้อมูลโดยตรง ซึ่งจะสร้างโปรแกรมโดยนัย
    *   ตัวอย่างคือระบบ **Sketchpad** ของ Ivan Sutherland (ปี 1962) ที่ช่วยให้ผู้ใช้สามารถวาดภาพบนหน้าจอและกำหนดข้อจำกัดต่างๆ (เช่น เส้นตั้งฉากกัน) ระบบจะใช้ตัวแก้ปัญหาแบบวนซ้ำ (iterative solver) เพื่อปรับรูปภาพให้เป็นไปตามข้อจำกัดนั้น ข้อจำกัดเหล่านี้จะคงอยู่แบบไดนามิก ทำให้เมื่อปรับขนาด รูปทรงจะยังคงสมบูรณ์
    *   Sutherland ยังได้สร้างการจำลองสะพานที่ผู้ใช้สามารถวาดและกำหนดข้อจำกัดทางกายภาพได้
    *   แนวคิดนี้หมายถึงการสร้างโปรแกรมโดยการจัดการข้อมูลโดยตรงและการใช้ชุดข้อจำกัด แทนการเขียนโค้ด ผู้บรรยายคาดการณ์ว่าในอนาคตเราจะสร้างเอกสารบนเว็บด้วยการจัดการโดยตรง โดยไม่มีภาษา Markup หรือ Stylesheet

*   **2. การเขียนโปรแกรมโดยใช้เป้าหมาย (Programming Using Goals):**
    *   แทนที่จะเขียนขั้นตอน (procedures) ผู้ใช้จะระบุสิ่งที่ต้องการ (goals) และให้คอมพิวเตอร์หาวิธีดำเนินการเอง
    *   **Sketchpad** ก็มีองค์ประกอบนี้ โดยผู้ใช้บอกว่าต้องการให้เส้นตั้งฉากกัน ไม่ได้บอกว่าจะวาดอย่างไร
    *   ระบบ **Planner** ของ Carl Hewitt สามารถให้เหตุผลทั้งไปข้างหน้า (จากขั้นตอน) และย้อนกลับ (จากเป้าหมาย) ได้
    *   **Prolog** ซึ่งพัฒนาต่อจาก Planner เน้นการแสดงโปรแกรมในรูปของเป้าหมาย และระบบจะหาวิธีการเพื่อให้บรรลุเป้าหมายเหล่านั้น
    *   อีกตัวอย่างคือ **การจับคู่รูปแบบ (Pattern Matching)** เช่นในภาษา SNOBOL และ Regular Expressions ของ Ken Thompson ใน Unix แทนที่จะเขียน parser ที่ทำงานเป็นขั้นตอน ผู้ใช้จะระบุรูปแบบที่ต้องการ และระบบจะหาวิธีจับคู่กับข้อความ
    *   แนวคิดการเขียนโปรแกรมแบบใช้เป้าหมายนี้จะสำคัญมากในยุคที่มีเครือข่ายคอมพิวเตอร์ทั่วโลก (intergalactic computer network/ARPANET/Internet) ที่ J.C.R. Licklider กำลังผลักดัน
    *   ในเครือข่ายดังกล่าว โปรแกรมที่เขียนขึ้นโดยคนต่างกัน ภาษาต่างกัน จะต้องสามารถสื่อสารกันได้ วิธีเดียวที่จะรองรับการขยายตัวได้คือ โปรแกรมต้องสามารถเจรจาและหาวิธีสื่อสารกันเอง เพื่อบรรลุเป้าหมายที่โปรแกรมเมอร์กำหนด
    *   การกำหนด API (Application Programming Interface) ล่วงหน้าจะไม่สามารถใช้งานได้จริง เพราะจะทำให้โปรแกรมผูกมัดกันและเปราะบาง ไม่สามารถรองรับการเปลี่ยนแปลงได้ การให้มนุษย์จัดการรายละเอียดระดับต่ำนี้เป็นปัญหาเช่นเดียวกับการเขียนโค้ดด้วย Machine Code

*   **3. การแสดงข้อมูลเชิงพื้นที่ (Spatial Representation of Information):**
    *   ปัจจุบันโปรแกรมส่วนใหญ่เป็นข้อความหลายบรรทัดในไฟล์ ซึ่งเหมาะกับสื่อแบบเชิงเส้น เช่น บัตรเจาะรูหรือเทปแม่เหล็ก
    *   แต่เมื่อมีจอแสดงผลวิดีโอเชื่อมต่อกับคอมพิวเตอร์ แนวคิดทุกอย่างก็เปลี่ยนไป จอแสดงผลเปรียบเสมือนแผ่นกระดาษแบบไดนามิกที่สามารถแสดงสิ่งต่างๆ เชิงพื้นที่ได้
    *   ระบบ **NLS** ของ Doug Engelbart ที่ SRI (มีการสาธิตเมื่อ 5 ปีก่อน) ใช้เมาส์ในการชี้ข้อมูลบนหน้าจอและแสดงมุมมองข้อมูลที่แตกต่างกัน เช่น จากรายการเป็นไดอะแกรม 2 มิติ
    *   ระบบ **GRAIL** จาก RAND Corporation เป็นระบบที่ช่วยให้เขียนโปรแกรมโดยใช้ผังงาน (flow charts) บนจอแสดงผลวิดีโอ โดยใช้ปากกาสไตลัสวาดบนแท็บเล็ต ระบบสามารถจดจำรูปวาด (เช่น กล่อง) และลายมือ เพื่อเปลี่ยนเป็นการเขียนโปรแกรมเชิงพื้นที่และการจัดการโดยตรง
    *   ใน **Smalltalk** ของ Xerox Parc แม้ซอร์สโค้ดจะอยู่ในรูปข้อความ แต่ก็จัดระเบียบในลักษณะเชิงพื้นที่ผ่าน "เบราว์เซอร์" ทำให้สามารถเข้าถึงและทำความเข้าใจโค้ดได้รวดเร็ว
    *   ผู้บรรยายมั่นใจว่าใน 40 ปีข้างหน้า จะไม่มีใครเขียนโค้ดในไฟล์ข้อความอีกแล้ว
    *   ระบบเหล่านี้ (NLS, GRAIL, Smalltalk, Plato) เป็นส่วนหนึ่งของ "คลื่นลูกใหม่" ของการประมวลผลแบบโต้ตอบ (interactive computing) ที่เน้นการตอบสนองทันทีทันใดของผู้ใช้ ซึ่งจะไม่มีความล่าช้าหรือหน่วงในส่วนต่อประสานผู้ใช้ในอนาคต

*   **4. การเขียนโปรแกรมแบบขนาน (Parallel Programming):**
    *   ปัจจุบันโปรแกรมของเราเป็นลำดับคำสั่งที่ทำทีละอย่าง ซึ่งเป็นผลมาจากสถาปัตยกรรมคอมพิวเตอร์แบบ von Neumann ที่มีโปรเซสเซอร์เดียวและหน่วยความจำส่วนใหญ่จะว่าง
    *   การประดิษฐ์วงจรรวม (integrated circuit) หรือไมโครโปรเซสเซอร์โดย Intel ทำให้โปรเซสเซอร์และหน่วยความจำทำจากวัสดุเดียวกัน (ซิลิคอน)
    *   ในมุมมองของซิลิคอน **คอมพิวเตอร์ควรมีลักษณะเป็นคอมพิวเตอร์ขนาดเล็กจำนวนมากที่ทำงานพร้อมกัน** แต่ละตัวมีโปรเซสเซอร์และสถานะของตัวเอง และสื่อสารกัน นี่คือสถาปัตยกรรมที่ช่วยเพิ่มประสิทธิภาพการคำนวณต่อพื้นที่ซิลิคอนสูงสุดและสามารถขยายขนาดได้ง่าย
    *   ดังนั้น เราจะต้องเขียนโปรแกรมบนฮาร์ดแวร์แบบขนาน
    *   วิธีปัจจุบันที่ใช้ Threads และ Locks เพื่อจัดการทรัพยากรที่ใช้ร่วมกันนั้นไม่สามารถรองรับการขยายตัวได้ และเป็นทางตัน
    *   ผู้บรรยายเชื่อว่า **Actor Model** ที่ Carl Hewitt คิดค้นขึ้นจะเข้ามาแทนที่ Actor Model ได้รับแรงบันดาลใจจากฟิสิกส์ โดยมีกระบวนการ (actors) จำนวนมากที่ทำงานแบบไม่พร้อมกัน มีสถานะของตัวเอง และส่งข้อความถึงกัน
    *   แนวคิดอื่นๆ ที่คล้ายกันกำลังเกิดขึ้น เช่น Communicating Sequential Processes ของ Tony Hoare
    *   สิ่งสำคัญคือ เราจะมีฮาร์ดแวร์แบบขนานขนาดใหญ่ และเราต้องการโมเดลการเขียนโปรแกรมแบบขนานที่ดีที่เข้ากับฮาร์ดแวร์นั้น

ผู้บรรยายสรุปว่า แนวคิดทั้งสี่นี้ (การจัดการข้อมูลโดยตรง, การเขียนโปรแกรมตามเป้าหมาย, การแสดงข้อมูลเชิงพื้นที่, และการเขียนโปรแกรมแบบขนาน) คือทิศทางที่ควรจะเป็นในอนาคต เขาเชื่อว่า **จะเป็นเรื่องน่าเสียดายอย่างยิ่งหากใน 40 ปีข้างหน้า เรายังคงเขียนโปรแกรมแบบเดิมๆ ด้วยชุดคำสั่งในไฟล์ข้อความและโมเดลเชิงลำดับ**

โศกนาฏกรรมที่ยิ่งใหญ่กว่าการที่แนวคิดเหล่านี้ไม่ถูกนำมาใช้คือ **การที่แนวคิดเหล่านี้ถูกลืมเลือนไป** แต่โศกนาฏกรรมที่ร้ายแรงที่สุดคือ **หากผู้คนลืมไปว่าเรายังสามารถมีแนวคิดใหม่ๆ เกี่ยวกับโมเดลการเขียนโปรแกรมได้**

ผู้บรรยายเตือนว่า **สถานการณ์ที่เลวร้ายที่สุดคือหากโปรแกรมเมอร์รุ่นต่อไปเติบโตขึ้นมาโดยไม่เคยสัมผัสกับแนวคิดเหล่านี้ และคิดว่าการเขียนโปรแกรมได้รับการแก้ไขและเข้าใจอย่างถ่องแท้แล้ว** การเติบโตมาพร้อมกับ "ความเชื่อ (dogma)" ทำให้ยากที่จะหลุดพ้น

เหตุผลที่แนวคิดดีๆ มากมายเกิดขึ้นในช่วงทศวรรษ 1960 ต้นทศวรรษ 1970 เป็นเพราะเทคโนโลยีพัฒนาไปมากพอที่จะใช้คอมพิวเตอร์ได้แล้ว แต่ก็ยังเป็นช่วงแรกๆ ที่ไม่มีใครรู้ว่าการเขียนโปรแกรมควรเป็นอย่างไร พวกเขาจึงลองทุกวิถีทาง และความคิดของพวกเขาก็เป็นอิสระ

ข้อคิดที่อันตรายที่สุดสำหรับคนสร้างสรรค์คือ **การคิดว่า "คุณรู้ว่ากำลังทำอะไรอยู่"** เพราะเมื่อคุณคิดเช่นนั้น คุณจะหยุดมองหาวิธีอื่นๆ และจะไม่สามารถมองเห็นวิธีใหม่ๆ ได้ เหมือนกับโปรแกรมเมอร์ไบนารีที่ไม่สามารถมองเห็นคุณค่าของ Assembler หรือ Fortran ได้เลย

**ข้อความหลักของวิดีโอนี้คือ หากเราไม่อยากเป็นเหมือนคนที่ติดอยู่กับวิธีคิดแบบเก่า เราต้องเปิดใจและยอมรับแนวคิดใหม่ๆ โดยเริ่มต้นจากการพูดกับตัวเองว่า "เราไม่รู้ว่าเรากำลังทำอะไรอยู่"** **"เราในฐานะสาขาไม่รู้ว่าเรากำลังทำอะไรอยู่ เราไม่รู้ว่าการเขียนโปรแกรมคืออะไร เราไม่รู้ว่าการประมวลผลคืออะไร เราไม่รู้แม้กระทั่งว่าคอมพิวเตอร์คืออะไร"** เมื่อเราเข้าใจและเชื่อในสิ่งนี้อย่างแท้จริง เราก็จะเป็นอิสระและสามารถคิดอะไรก็ได้